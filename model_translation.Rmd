---
title: "Model translation pipeline"
output: html_notebook
---

# Load libraries and functions

```{r}

library(decoupleR)
library(OmnipathR)
library(caret)
library(olsrr)
library(nloptr)
library(ropls)
library(matrixStats)

source("E:/Jose Luis/Documents/GitHub/FattyLiverModeling/utils/wrapper_DECOUPLER.R")
source("E:/Jose Luis/Documents/GitHub/FattyLiverModeling/utils/plotting_functions.R")
source("E:/Jose Luis/Documents/GitHub/FattyLiverModeling/modeling/functions_translation_jose.R")

options(expressions = 5e5)

dir_data <- "E:/Jose Luis/Documents/GitHub/FattyLiverModeling/data/"

MAE <- rep(0,10)
for (ff in 1:length(idx_train_CV)){
  # Split data
  idx_train <- idx_train_CV[[ff]]
  Ytrain <- Yh[idx_train]
  Ytest <- Yh[-idx_train]
  
  MAE[ff] <- abs(Ytest - mean(Ytrain)) %>% mean()
}
```


# Load datasets 

Load datasets and pre-process. Pre-processing is intersecting features, log CPM normalization
centering, and PCA for visualization although PCA is not crucial

Doing a more stringent threshold to keep variable genes in all datasets. COuld relax to keep variable
genes in at least one datasets, but this allows for faster execution for testing







# Check information preservation

See how model prediction worsens when we use the MPS space

Make a function for this

```{r}
target_dataset <- "Kostrzewski" #"Kostrzewski" #, "Govaere", "Wang"
# Project human data onto key components of MPS and back project
L <-  1:data_list[[target_dataset]]$pca$nPC  #1:ncol(data_list[[target_dataset]]$pca$rotation) # 
Xh <- t(data_list$Hoang$data_center)
Xm <- t(data_list[[target_dataset]]$data_center)
# Project and backproject on MPS, and re=project onto human PC space but only the LVs of interest to the regression model
Wh <- plsr_mod$Wf
Wm <- data_list[[target_dataset]]$pca$rotation[,L]
S_h <- Xh %*% Wh
S_hm <- Xh %*% Wm %*% t(Wm) %*% Wh

# Try retraining PLSR
#plsr_mod2 <- get_plsr_mod(X = Xh %*% Wm %*% t(Wm), Y = Yh, idx_train_CV = idx_train_list, ncomp_PLSR = 7)

# Retrain model (same features but changing scaling variables)
mod_plsr <- lm(Yh ~., data = data.frame(Yh, S_h))
mod_plsr2 <- lm(Yh ~., data = data.frame(Yh, S_hm))


# Predict NAFLD score with model trained on original human data
# Plot
plt_mod_project <- rbind(data.frame(NAS = Yh, 
                 y = cbind(1, S_h) %*% coef(mod_plsr), 
                 source = "Original"),
      data.frame(NAS = Yh, 
                 y = cbind(1, S_hm) %*% coef(mod_plsr), 
                 source = "Backprojected"),
      data.frame(NAS = Yh, 
                 y = cbind(1, S_hm) %*% coef(mod_plsr2), 
                 source = "Backprojected retrain")) %>%
  mutate(source = factor(source, levels = c("Original", "Backprojected", "Backprojected retrain"))) %>%
  ggplot(aes(x = NAS, y = y, color = factor(source))) +
    geom_point(show.legend = F) +
    geom_abline(slope = 1, intercept = 0, linetype = 2) +
    facet_wrap(facets = vars(source), nrow = 1) +
    labs(x = "NAS measured", y = "NAS predicted", color = "Reference space") +
    stat_cor(aes(label = after_stat(r.label)), show.legend = F, color = "black", label.y = 6)

plt_mod_project <- add_theme(plt_mod_project)# Plot pathway scores in PC loadings in Hoang data

```

# Analyze importance of MPS PCs

Calculate prediction error (square norm) using each MPS PC - retraining to potentially compensate loss in performance

```{r}
Wm_rank <- rank_LV_MPS(Xh, Yh, Wh, Bm, Wm, retrain = F)
plt_rank <- data.frame(rank = factor(Wm_rank$E_top), R2Y = 100*Wm_rank$E_rem_out/Wm_rank$E_ref) %>%
            ggplot(aes(x = reorder(rank, -R2Y), y = R2Y)) +
              geom_col(fill = "steelblue") +
              labs(x = "PC removed", y = "R2Y (% of max)")

plt_rank <- add_theme(plt_rank)

# Interpret PCs with Progeny
pwy_acts_PC <- get_pwy_activities(data = Wm[,c(3,4,7,1)])

corrplot::corrplot(pwy_acts_PC$MAT %>% scale(),
                   p.mat = pwy_acts_PC$MAT_pval,
                   sig.level = c(0.001, 0.01, 0.05), pch.cex = 0.9,
                   insig = 'label_sig', is.corr = F, method = "color", 
                   col=colorRampPalette(c("#053061","white","#67001F"))(100), 
                   tl.col = "black", type = "full", col.lim = c(-4,4),
                   cl.pos = 'b', cl.ratio = 0.2, cl.length = 5)
            
```

# Loop through each MPS to do ANOVA based on exp factors

We do this to see which PCs are "addressable", meaning that the variation comes from 
experimental factors and not technical variability


```{r}
key_PC <- 1:20 #c(3,4,7,1)
PC_scores <- data_list$Kostrzewski$pca$x[,key_PC]
PC_exp_mat <- cbind(PC_scores, data_list$Kostrzewski$metadata)


exp_factors <- exp_factors <- c("NPC", "Background", "TGF", "LPS",  "Cholesterol", "Fructose") #data_list$Kostrzewski$exp_factors 
exp_factors_pval <- matrix(0, nrow = length(exp_factors), ncol = length(key_PC))
rownames(exp_factors_pval) <- exp_factors
colnames(exp_factors_pval) <- paste0("PC", key_PC)
exp_factors_effect <- exp_factors_pval

ii <- 1
for (pc in key_PC){
  aov_formula <- paste0("PC", pc, " ~ ",
                        paste(exp_factors, collapse = " + ")
                        )
  
  an <- aov(as.formula(aov_formula), data = PC_exp_mat)
  exp_factors_pval[, ii] <- summary(an)[[1]][["Pr(>F)"]][1:length(exp_factors)]
  
  # Fit linear model to get coefficients (effect size) - exclude intercept
  exp_factors_effect[, ii] <- coef(lm(as.formula(aov_formula), data = PC_exp_mat))[-1]
  ii <- ii + 1
}


plt_dummy <- data.frame(data_list$Kostrzewski$metadata, data_list$Kostrzewski$pca$x) %>%
              ggplot(aes(x = PC1, y = PC2, color = NPC)) +
                geom_point() +
                stat_ellipse() +
                scale_color_brewer(palette = "Dark2")

plt_dummy <- add_theme(plt_dummy)



# Plot - zscore the weights in each PC
corrplot::corrplot(exp_factors_effect[,c(3,4,7,1)] %>% scale(),
                   p.mat = exp_factors_pval[,c(3,4,7,1)],
                   sig.level = c(0.001, 0.01, 0.05), pch.cex = 0.9,
                   insig = 'label_sig', is.corr = F, method = "color", 
                   col=colorRampPalette(c("#053061","white","#67001F"))(100), 
                   tl.col = "black", type = "full", col.lim = c(-3,3),
                   cl.pos = 'b', cl.ratio = 0.2, cl.length = 5)

```

# Additional approcha

Do not use MPS PCs directly, but build a predictive space by finding linear combinations of existing PCs
to find a new more translatable basis of the MPS

```{r}
# Find set of candidate vectors (new basis)
Wh <- plsr_mod$Wf
Wm_new_basis <- NULL
# Start with the MPS as the basis vectors - choose PCs that have more than 0.1% variance
# to narrow down the search a bit
#L <- 1:data_list[[target_dataset]]$pca$nPC
Wm <- data_list$Kostrzewski$pca$rotation[,data_list$Kostrzewski$pca$var_per >= 0.1]
#Wm <- data_list$Kostrzewski$pca$rotation[,L]
theta <- Wm
# Store sum of squared error
Ey <- NULL
d_Ey <- 100
ii <- 0
while (d_Ey > 1){
  # Update index
  ii <- ii + 1
  # Find optimal weights to combine these vectors
  res_opt <- optim_function_evolutionary(X = Xh, Wh = Wh, Wm = Wm_new_basis, 
                                       theta = theta, mod_coefs = Bm)

  # Extract optimal new direction
  Wm_opt <- res_opt$Wopt
  colnames(Wm_opt) <- paste0("LV_opt",ii)
  
  # Augment Wm_new
  Wm_new_basis <- cbind(Wm_new_basis, Wm_opt)
  
  # Calculate correlation with new predictions
  Ypred <- cbind(1, Xh %*% Wm_new_basis %*% t(Wm_new_basis) %*% Wh) %*% Bm
  Ey[ii] <- sum((Ypred - Yh)^2)
  d_Ey <- ifelse(ii == 1, Ey[ii], 100*abs(Ey[ii] - Ey[ii-1])/Ey[ii])
  
  # Find new basis for next iteration - deflate MPS space
  theta <- find_extra_basis(Wm, Wm_new_basis, Xh, ncomp = ncol(Wm) - ii)
  theta <- theta$theta
}
# After exiting it means the last component was unnecessary, so we exclude it
Wm_new_basis <- matrix(data = Wm_new_basis[,-ii], ncol = ii - 1)
colnames(Wm_new_basis) <- paste0("LV_opt",1:ncol(Wm_new_basis))
rownames(Wm_new_basis) <- rownames(Wm)

# Plot Yh predicted with this reduced space vs the larger MPS space
Ypred1 <- cbind(1, Xh %*% Wm %*% t(Wm) %*% Wh) %*% Bm
Ypred2 <- cbind(1, Xh %*% Wm_new_basis %*% t(Wm_new_basis) %*% Wh) %*% Bm

plt_new_basis <- plot_scatter(x = Ypred1, y = Ypred2, 
                              xlab = "NAS full MPS space", ylab = "NAS reduced space") +
                  geom_abline(intercept = 0, slope = 1, linetype = 2, color = "indianred") +
                  stat_cor(aes(label = after_stat(r.label)), show.legend = F, color = "black")

# Find experimental factors that contribute to the new latent variable (to do: Wrap in functions)

aov(y ~., data = data.frame(y = as.numeric(Xm %*% Wm_new_basis), 
                            data_list$Kostrzewski$metadata[, exp_factors])) %>% summary()

# Project MPS data on this space
plt_new_basis_project <- data.frame(y = as.numeric(Xm %*% Wm_new_basis),
                                    data_list$Kostrzewski$metadata) %>%
                          ggplot(aes(x = y, y = reorder(Combination_name, y), fill = TGF)) +
                            geom_boxplot() +
                            facet_grid(rows = vars(NPC), cols = vars(Background)) +
                            labs(x = "LV1 score", y = NULL) 

plt_new_basis_project <- add_theme(plt_new_basis_project) + scale_fill_brewer(palette = "Dark2")

# Project human data here
plt_dummy <- data.frame(y = as.numeric(Xm %*% Wm_new_basis),
                        data_list$Kostrzewski$metadata) %>%
              ggplot(aes(x = Fructose, y = y)) +
                geom_violin() 
```



# Look for additional latent variables (i,e, loading vectors)

Look for additional "PCs" that, if added to the MPS dataset, can retrieve lost information. For this,
do not do the regression in the MPS space. Rather, project human to limited MPS space
and backproject to get a compressed feature matrix. Then, re-project this one onto 
the human PC space and use values in regression model 

Number of additional vectors could be obtained with cross validation

```{r}
# Find set of candidate vectors (new basis)
L <- 1:ncol(data_list$Kostrzewski$pca$rotation) #1:data_list$Kostrzewski$pca$nPC #
Wh <- plsr_mod$Wf
Wm_new <- data_list$Kostrzewski$pca$rotation[,L]
theta <- find_extra_basis(Wh, Wm_new, Xh, ncomp = ncol(Wh))
theta <- theta$theta

# Find optimal weights to combine these vectors
res_opt <- optim_function_evolutionary(X = Xh, Wh = Wh, Wm = Wm_new, 
                                       theta = theta, mod_coefs = Bm)

# Extract optimal new direction
Wm_opt <- res_opt$Wopt

Ypred1 <- cbind(1, Xh %*% cbind(Wm_new_basis, Wm_opt) %*% t(cbind(Wm_new_basis, Wm_opt)) %*% Wh) %*% Bm
Ypred2 <- cbind(1, Xh %*% Wm_new_basis %*% t(Wm_new_basis) %*% Wh) %*% Bm

# Retrain
Ypred1 <- lm(Yh ~ Xh %*% cbind(Wm_new_basis, Wm_opt) %*% t(cbind(Wm_new_basis, Wm_opt)) %*% Wh) %>% predict()
Ypred2 <- lm(Yh ~ Xh %*% Wm_new_basis %*% t(Wm_new_basis) %*% Wh) %>% predict()

df <- rbind(data.frame(x = Yh, y = Ypred2, Basis = "MPS"),
           data.frame(x = Yh, y = Ypred1, Basis = "Expanded"))


plt_aug <- plot_scatter(x = df$x, 
             y = df$y,
             xlab = "NAS measured",
             ylab = "NAS predicted",
             aes_extra = aes(color = Basis),
             args_extra = list(Basis = df$Basis)) +
  geom_abline(slope = 1, intercept = 0, linetype = 2, color = "indianred") +
  lims(x = c(min(Yh),max(Yh)), y = c(min(Yh),max(Yh))) +
  facet_wrap(facets = vars(Basis), nrow = 1) +
  stat_cor(aes(label = after_stat(r.label)), show.legend = F, color = "black")



plt_dummy <- plot_scatter(x = Xm %*% Wm_new_basis, 
                           y = Xm %*% Wm_opt, 
                           aes_extra = aes(color = TGF), 
                           args_extra = list(TGF = data_list$Kostrzewski$metadata$TGF),
                          ) +
              stat_ellipse() +
             scale_color_brewer(palette = "Dark2") +
             labs(x = "MPS LV1", y = "MPS LV extra")

plt_dummy <- plot_scatter(x = Xh %*% Wm_opt, 
                           y = Yh, 
                           aes_extra = aes(color = NAS), 
                           args_extra = list(NAS = Yh),
                          ) +
              scale_color_viridis_c() +
             labs(x = "MPS LV extra", y = "NAS measured")

# Project Wang dataset
plt_dummy <- data.frame(x = t(data_list$Wang$data_center) %*% Wm_opt %>% as.numeric(),
                        data_list$Wang$metadata) %>%
              ggplot(aes(x = x, y = scaffold, fill = media)) +
                geom_boxplot() +
                labs(x = "Score on MPS LV extra", y = NULL)
plt_dummy <- add_theme(plt_dummy) + theme(legend.position = "top")

plt_dummy <- plot_scatter(x = t(data_list$Wang$data_center) %*% Wm_new_basis %>% as.numeric(), 
                           y = t(data_list$Wang$data_center) %*% Wm_opt  %>% as.numeric() , 
                           aes_extra = aes(color = Condition), 
                           args_extra = list(Condition = data_list$Wang$metadata$condition),
                          ) +
             scale_color_brewer(palette = "Dark2") +
             labs(x = "MPS LV1", y = "MPS LV extra")
             

```

## Interpret loadings of new important PCs - pathway and TF activities

TO DO: Use PCGSEA for further interpretation

```{r}

dummy <- cbind(Wm_new_basis, Wm_opt)
colnames(dummy) <- c("LV1_MPS", "LV_extra_MPS")
pwy_acts_extra <- get_pwy_activities(dummy)
tf_acts_extra <- get_TF_activities(dummy)


# Plot
ggplot(pwy_acts_extra$TABLE, aes(x = reorder(source, score), y = score)) + 
    geom_bar(aes(fill = score), stat = "identity", color = "black", show.legend = F) +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) +
    labs(x = "Pathway score", y = NULL) +
    facet_wrap(facets = vars(condition), nrow = 1, scales = "free")

# Plot pathway scores in PC loadings in Hoang data

# nice red #67001F
corrplot::corrplot(pwy_acts_extra$MAT %>% scale(),
                   p.mat = pwy_acts_extra$MAT_pval,
                   sig.level = c(0.001, 0.01, 0.05), pch.cex = 0.9,
                   insig = 'label_sig', is.corr = F, method = "color", 
                   col=colorRampPalette(c("#053061","white","indianred"))(100), 
                   tl.col = "black", type = "full", col.lim = c(-3,3), cl.offset = 0.2,
                   cl.align.text = "l", cl.length = 3, cl.ratio = 0.2, cl.pos = "b")



loading_perturb_viper <- run_viper(tf_acts_extra$MAT, resp_net, minsize = 5)


```

# Analyze pathway activity at sample level

Bug with PCA plot and metadata, so manual for now
```{r}

pwy_acts_MPS <- get_pwy_activities(data_list$Kostrzewski$data_center)
pwy_acts_Human <- get_pwy_activities(data_list$Hoang$data_center)


plt_pca_pwy_Human <- plot_pca(pwy_acts_Human$MAT, scale_data = F, return_data = T)
plt_dummy <- plot_scatter(x = plt_pca_pwy_Human$data$x[,1], y = plt_pca_pwy_Human$data$x[,2],
                          xlab = "PC1 (60.1%)", ylab = "PC2 (13.5%)", aes_extra = aes(color = color),
                          args_extra = data.frame(color = Yh)) +
            labs(color = "NAS") + scale_color_viridis_c()

plt_dummy <- plot_scatter(x = as.numeric(pwy_acts_Human$MAT["JAK-STAT", ]), y = Yh)

plsr_pwy <- opls(x = pwy_acts_Human$MAT %>% t(), 
                   y = Yh,
                   scaleC = "center",
                   crossvalI = 5,
                   predI = NA)


plt_pca_pwy_MPS <- plot_pca(pwy_acts_MPS$MAT, scale_data = F, return_data = T)
plt_dummy <- plot_scatter(x = plt_pca_pwy_MPS$data$x[,1], y = plt_pca_pwy_MPS$data$x[,2],
                          xlab = "PC1 (78.9%)", ylab = "PC2 (9.12%)", aes_extra = aes(color = color),
                          args_extra = data.frame(color = data_list$Kostrzewski$metadata$TGF)) +
            labs(color = "TGFb added") + scale_color_brewer(palette = "Dark2")


```

# Dummy data - remove conditions

```{r}
keep_sample <- data_list$Kostrzewski$metadata$Combination_name %in% c("Control", "TGF-B")
data_dummy <- data_list$Kostrzewski$data_center[, keep_sample]
data_dummy <- data_dummy - rowMeans(data_dummy)

pca_dummy <- plot_pca(data_dummy, scale_data = F, return_data = T)

# Project
score_dummy <- t(data_dummy) %*% Wm_new_basis
```


# Repeat for random data permutations

Build PLSR models with 7 components but with shuffled phenotype labels. Then, find complementary
vectors Wm_opt for each (Wm_rand) to get a null distribution of pathway activities.
This part is very slow and needs to be improved

```{r}
Wm_rand <- matrix(0, nrow = nrow(Wm), ncol = 100)
L <- 1:data_list$Kostrzewski$pca$nPC #1:ncol(data_list$Kostrzewski$pca$rotation) #
Wm_new <- data_list$Kostrzewski$pca$rotation[,L]

#plsr_outliers <- paste0("GSM3758", c("047", "011", "045", "076", "012", "033", "082", "009"))
#keep <- !(rownames(Xh) %in% plsr_outliers)

for (ii in 1:100){
  plsr_mod2 <- get_plsr_mod(X = Xh, Y = Yh, idx_train_CV = idx_train_list, ncomp_PLSR = 7)
  Wh <- plsr_mod2$W
  theta <- find_extra_basis(Wh, Wm_new, Xh, ncomp = ncol(Wh))
  theta <- theta$theta

  # Find optimal weights to combine these vectors
  res_opt <- optim_function_evolutionary(X = Xh, Wh = Wh, Wm = Wm_new, 
                                       theta = theta, mod_coefs = coef(plsr_mod$mod_lm))

  # Extract optimal new direction
  Wm_rand[,ii] <- res_opt$Wopt
}
rownames(Wm_rand) <- rownames(Wm_opt)
pwy_acts_rand <- get_pwy_activities(Wm_rand)
save(Wm_rand, file = "Random_opt_vectors.RData")
```












Look at correlations between PC scores across datasets. This will indicate common directions
of gene expression covariance

```{r}
corrplot::corrplot(cor(data_MPS_joint), order = "hclust", method = "color", tl.col = "black", type = "full")

# Plot
corrplot::corrplot(pwy_acts$MAT[,c(1,2,3,12,15)] %>% scale(),
                   p.mat = pwy_acts$MAT_pval[,c(1,2,3,12,15)],
                   sig.level = c(0.001, 0.01, 0.05), pch.cex = 0.9,
                   insig = 'label_sig', is.corr = F, method = "color", 
                   col=colorRampPalette(c("#053061","white","#67001F"))(100), 
                   tl.col = "black", type = "full", col.lim = c(-4,4), cl.offset = 0.5,
                   cl.align.text = "l", cl.ratio = 0.4)
```




# Run CARNIVAL on PC scores as a way of predicting perturbations along a latent variable

CARNIVAL pipeline


Get TF and PWY scores

```{r}
# Get tf_acts and pwy_acts
data_PC <- pca$rotation[,1]
tf_acts <- get_TF_activities(data = data_PC, tf_keep = names(data_PC), method = "ulm")
pwy_acts <- get_pwy_activities(data = data_PC)
# Get top percentile TFs
top_tfs <- tf_acts$TABLE %>% filter(score > quantile(score, 0.9) | score < quantile(score, 0.1))
```



Build PKN from omnipath and incorporate the gene expression data. Can skip and load directly

```{r}
# Include only genes present in at least 50% of samples (threshold of 5 cpm for now)
# p_val cutoff for TF of 0.01. Include all TF targets in genes to keep
tf_targets <- top_tfs$source
genes_keep <- c(rownames(data_Feaver)[rowSums(data_Feaver > 1) > 8], tf_targets) %>% unique()
pkn_all <- build_PKN_Omnipath(genes_keep = genes_keep, 
                              tf_target = tf_targets, 
                              keep_complexes = T, save_name = "pkn_test.tsv")


```

Run CARNIVAL 

```{r}
    carnivalOptions <- defaultCplexCarnivalOptions(solverPath = path_cplex)
    dir.create("Dummy", showWarnings = FALSE)
    carnivalOptions$outputFolder <- "Dummy"
    
    
    # Get pathway weights
    pwy_weights <- get_pwy_weights(pwy_acts$TABLE)
    
    
    #  clk <- Sys.time()
    carnival_out <- runInverseCarnival(
                      measurements = tf_acts$MAT[tf_targets,1],
                      priorKnowledgeNetwork = pkn_all$SIF,
                      weights = pwy_weights, 
                      carnivalOptions =  carnivalOptions
                    )
    
    save(carnival_out, tf_acts, pwy_weights,
            file = "test PCAinverse_carnival_solutions.RData")
    
    
    
  



# Save node attributes and weighted SIF - remove nodes with < 5% activity
carnival_node_weights <- carnival_out_vanilla[["nodesAttributes"]] %>% filter(abs(AvgAct) >= 5)
# Trim edges between nodes that are not active or edges that are not active (5%)
carnival_edge_weights <- carnival_out_vanilla[["weightedSIF"]] %>% 
                          filter(Node1 %in% carnival_node_weights$Node &
                                 Node2 %in% carnival_node_weights$Node &
                                 abs(Weight) > 5)

# Annotate nodes (TF, receptor, or regular) - annotating receptors based on curated omnipath list (TO DO: Load somewhere)
carnival_node_weights <- carnival_node_weights %>%
                         mutate(NodeClass = ifelse(Node %in% tf_targets, "TF",
                                                   ifelse(Node %in% LR_list$target_genesymbol, "R", "S")))

# Export
write.csv(carnival_node_weights,"node_weights.csv", row.names = F, quote = F)
write.csv(carnival_edge_weights,"edge_weights.csv", row.names = F, quote = F)

```
